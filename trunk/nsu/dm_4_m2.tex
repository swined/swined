\documentclass[russian]{article}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}
\usepackage{amssymb,esint,babel,qtree}
\makeatletter
\makeatother
\pagestyle{myheadings}
\markright{Александров А., 3372}

\begin{document}

\section*{2.1}

\paragraph*{а}

ищем кратчайшее ребро. если оно не образует цикл с выбранными ранее, добавляем его в дерево, иначе выбрасываем из таблицы.

\begin{tabular}{|c|c|c|c|c|c|c|c|}\hline
    & 1  & 2  & 3  & 4	& 5	 & 6  & 7\\\hline
1	& -- & {\bf 36} & 44 & {\bf 37} & 41 & 53 & 43\\\hline
2	&    & -- & 48 & 57 & 43 & 45 & 51\\\hline
3	&    &    & -- & 39 & 39 & {\bf 42} & {\bf 38}\\\hline
4	&    &    &    & -- & 52 & 51 & {\bf 34}\\\hline
5	&    &    &    &    & -- & 49 & {\bf 35}\\\hline
6	&    &    &    &    &    & -- & 45\\\hline
7	&    &    &    &    &    &    & -- \\\hline
\end{tabular}

\Tree [.4 7 ]

\Tree [.7 4 5 ]

\Tree [.7 4 5 ]
\Tree [.1 2 ]

\Tree [.4 [.7 5 ] [.1 2 ] ]

\Tree [.4 [.7 3 5 ] [.1 2 ] ]

выкидываем ребра (3,4), (3,5), (4,5), т.к. они образуют циклы

\Tree [.4 [.7 [.3 6 ] 5 ] [.1 2 ] ]

\paragraph*{б}

пусть полученное дерево $T_s$ неоптимально, а значит существует оптимальное дерево $T_o$. количество ребер $T_s$ и $T_o$ совпадает.
$E(T_s) = \{e_1, ..., e_{n-1}\}$, $w_i = w(e_i)$. $E(T_o) = \{e_1^*, ..., e_{n-1}^*\}$, $w_i* = w(e_i^*)$.
$w(T_s)=\sum_{i=1}^{n-1}w_i$, $w_i \ge w_j \forall i>j$. $w(T_o)=\sum_{i=1}^{n-1}w_i^*$, $w_i^* \ge w_j^* \forall i>j$.
$w(T_s) > w(T_o) \Rightarrow \exists min k : w_k > w_k^*$, но это невозможно, т.к. $w_k > w_{k-1}^* \ge ... $ .
в момент $k$ работы алгоритма найдется $k$ ребер, образующих лес и более легких, чем $e_k$. 
по лемме о пополнении леса в ${e_1^*, ..., e_k^*}$ существует ребро, не входящее в $\{e_1, ..., e_k\}$ и такое, что добавление его в $\{e_1, ..., e_k\}$ порождает лес $\Rightarrow$ противоречие.

\end{document} 